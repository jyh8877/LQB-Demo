C51 COMPILER V9.59.0.0   MAIN                                                              01/19/2025 15:29:08 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\C51\C51\BIN\C51.EXE User\main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Hardware;.\User) DEBUG OBJECTE
                    -XTEND PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          pdata unsigned char LedBuf[8]={1,1,1,1,0,0,0,0},SegBuf[8] = {16,16,16,16,16,16,16,16};
   3          unsigned char Time[3]={11,22,33},RecTime[3],UartBufIndex;
   4          pdata unsigned char UartBuf[10];
   5          idata unsigned char UlDis,ADVal,DaVal,TaskNum,SysTick;
   6          unsigned long int uwTime;
   7          float Temper;
   8          unsigned int TemperShow,Frep;
   9          unsigned int Time1s;
  10          void Timer0_Init(void)          //100微秒@12.000MHz
  11          {
  12   1              AUXR &= 0x7F;                   //定时器时钟12T模式
  13   1              TMOD &= 0xF0;                   //设置定时器模式
  14   1          TMOD |= 0x05;
  15   1              TL0 = 0x00;                             //设置定时初始值
  16   1              TH0 = 0x00;                             //设置定时初始值
  17   1              TF0 = 0;                                //清除TF0标志
  18   1              TR0 = 1;                                //定时器0开始计时
  19   1      }
  20          void Timer1_Init(void)          //1毫秒@12.000MHz
  21          {
  22   1              AUXR &= 0xBF;                   //定时器时钟12T模式
  23   1              TMOD &= 0x0F;                   //设置定时器模式
  24   1              TL1 = 0x18;                             //设置定时初始值
  25   1              TH1 = 0xFC;                             //设置定时初始值
  26   1              TF1 = 0;                                //清除TF1标志
  27   1              TR1 = 1;                                //定时器1开始计时
  28   1          ET1 = 1;
  29   1          EA = 1;
  30   1      }
  31          void DataProc(void)
  32          {
  33   1          if(Time1s % 150)return;
  34   1          //ReadTime(RecTime);
  35   1          Temper = ReadTemp() ;
  36   1              TemperShow = Temper * 10;
  37   1              
  38   1      }
  39          void KeyProc(void)
  40          {
  41   1      
  42   1          static unsigned int KeyOld,KeyVal,KeyDown,KeyUp;
  43   1          if(Time1s % 20) return;
  44   1          KeyVal = KeyRead();
  45   1          KeyUp = ~KeyVal & (KeyOld ^ KeyVal);
  46   1          KeyDown = KeyVal & (KeyOld ^ KeyVal);
  47   1              KeyOld = KeyVal;
  48   1        
  49   1      }
  50          void SegProc(void)
  51          {
  52   1          if(Time1s % 20) return;
  53   1          // SegBuf[7] = RecTime[2] % 10;
  54   1          // SegBuf[6] = RecTime[2] / 10;
C51 COMPILER V9.59.0.0   MAIN                                                              01/19/2025 15:29:08 PAGE 2   

  55   1          // SegBuf[5] = 17;
  56   1          // SegBuf[4] = RecTime[1] % 10;
  57   1          // SegBuf[3] = RecTime[1] / 10;
  58   1          // SegBuf[2] = 17;
  59   1          
  60   1          SegBuf[7] = Frep         % 10;
  61   1          SegBuf[6] = (Frep   / 10 % 10) ;
  62   1          SegBuf[5] = Frep   / 100 %10;
  63   1          SegBuf[4] = Frep  / 1000 %10;
  64   1          SegBuf[3] = Frep / 10000;
  65   1      } 
  66          void ADDA(void)
  67          {
  68   1          ADVal = AdRead(0x41);
  69   1          DaWrite(DaVal);
  70   1      }
  71          void GetTime(void)
  72          {
  73   1          ReadTime(RecTime);
  74   1      }
  75          void ReadUlDis(void)
  76          {
  77   1          UlDis = GetUlSound();
  78   1      }
  79          void LedProc(void)
  80          {
  81   1          LedDisp(LedBuf);
  82   1      }
  83          void UartProc(void)
  84          {
  85   1          if(UartBufIndex <= 0)
  86   1              return;
  87   1          if(SysTick > 10)
  88   1          {
  89   2              SysTick = 0;
  90   2              memset(UartBuf,0,UartBufIndex);
  91   2              UartBufIndex = 0;
  92   2          }
  93   1      }
  94          
  95          typedef struct
  96          {
  97              void (*TaskFunc)(void);
  98              unsigned long int Ratems;
  99              unsigned long int LastRun;
 100              }TaskType;
 101          TaskType TaskList[] ={
 102              {GetTime,100,0},
 103              {ADDA,160,0},
 104              {SegProc,100,0},
 105              {UartProc,10,0},
 106              {LedProc,1,0}
 107          };
 108          void TaskListInit()
 109          {
 110   1          TaskNum = sizeof(TaskList) / sizeof(TaskType);
 111   1      }
 112          void TaskRun(void)
 113          {
 114   1          unsigned char i;
 115   1          for(i = 0;i < TaskNum;i++)
 116   1          {
C51 COMPILER V9.59.0.0   MAIN                                                              01/19/2025 15:29:08 PAGE 3   

 117   2              unsigned long int NowTime = uwTime;
 118   2              if(NowTime > (TaskList[i].LastRun + TaskList[i].Ratems))
 119   2              {
 120   3                  TaskList[i].LastRun = NowTime;
 121   3                  TaskList[i].TaskFunc();
 122   3              }
 123   2          }
 124   1      }
 125          
 126          void main()
 127          {
 128   1          TaskListInit();
 129   1          SetTime(Time);
 130   1              Timer0_Init();
 131   1          Timer1_Init();
 132   1          while(1)
 133   1          {
 134   2              TaskRun();
 135   2          }
 136   1      }
 137          
 138          void Routine1(void) interrupt 3 
 139          {
 140   1          static unsigned char SegPos = 0;
 141   1          Time1s++;uwTime++;SysTick++;
 142   1          if(Time1s == 1000)
 143   1          {
 144   2              Frep = ((TH0 << 8) | TL0);
 145   2              TH0 = TL0 = 0;
 146   2              Time1s = 0;
 147   2          }
 148   1          
 149   1          SegPos = (++SegPos) % 8;
 150   1          if(SegBuf[SegPos] > 20)
 151   1              SegDisp(SegPos,SegBuf[SegPos]-'.',1);
 152   1          else
 153   1              SegDisp(SegPos,SegBuf[SegPos],0);
 154   1      }
 155          
 156          void UartRoutine(void) interrupt 4
 157          {
 158   1          if(RI)
 159   1          {
 160   2              SysTick = 0;
 161   2              UartBuf[UartBufIndex++] = SBUF;
 162   2              RI = 0;
 163   2              if(UartBufIndex > 10)UartBufIndex = 0;
 164   2                  UartBufIndex = 0;
 165   2          }
 166   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    715    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     26    ----
   DATA SIZE        =     85       5
   IDATA SIZE       =      5    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
